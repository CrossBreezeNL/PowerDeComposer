<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<PowerDeComposerConfig>
	<Decompose>
	
		<!-- Specify the nodes to remove before decomposing. -->
		<NodeRemovals>
			<!-- Remove the object count on the PowerDesigner processing instruction. -->
			<!-- If we try to remove the whole processing instruction using the xpath below, we get an error: First char after <? invalid -->
			<!-- <NodeRemoval xpath="/processing-instruction('PowerDesigner')" /> -->
			<!-- If we try to remove an attribute on a processing instruction it doesn't do anything. This is because a processing instruction is not a formal XML entity. So it can only be handled as a whole. -->
			<!-- <NodeRemoval xpath="//processing-instruction('PowerDesigner')/@Objects" /> -->
			<!-- Remove the symbols count on the PowerDesigner processing instruction. -->
			<!-- <NodeRemoval xpath="//processing-instruction('PowerDesigner')/@Symbols" />  -->
			
			<!-- Remove the CreationDate, Creator, ModificationDate & Modifier from all Shortcuts. -->
			<NodeRemoval xpath="//Shortcut/CreationDate" />
			<NodeRemoval xpath="//Shortcut/Creator" />
			<NodeRemoval xpath="//Shortcut/ModificationDate" />
			<NodeRemoval xpath="//Shortcut/Modifier" />
			<!-- Remove the TargetModelLastModificationDate from all TargetModels. -->
			<NodeRemoval xpath="//TargetModel/TargetModelLastModificationDate" />
			<!-- Remove the c:FullShortcutModel from all TargetModels. -->
			<!-- <NodeRemoval xpath="//o:TargetModel/c:FullShortcutModel" /> -->
		</NodeRemovals>
		
		<!-- Specify which elements should be decomposed. -->
		<!-- The DecomposableElement is implicitly a AllConditions group. -->
		<DecomposableElement>
			<!-- The element must have a ObjectID and a Code element as childs. -->
			<ElementCondition xpath="./ObjectID and ./Code" />
			<!-- Use the parent axis on the current node to set a predicate on the parent. -->
			<!-- Decompose all elements where the parent name starts with 'c:' (these are the collections in PowerDesigner). -->
			<ElementCondition xpath="parent::node()[starts-with(name(), 'c:')]" />
			<!-- Don't decompose the Children collection (this is the higher level collection of the model). -->
			<ElementCondition xpath="parent::node()[name() != 'c:Children']" />
			<!-- LDM collections not to decompose. -->
			<ElementCondition xpath="parent::node()[name() != 'c:Attributes']" />
			<ElementCondition xpath="parent::node()[name() != 'c:Identifiers']" />
			<!-- PDM collections not to decompose. -->
			<ElementCondition xpath="parent::node()[name() != 'c:Columns']" />
			<ElementCondition xpath="parent::node()[name() != 'c:Keys']" />
			
			<!-- Example for comparing on the element name. -->
			<!-- <ElementCondition xpath="name() = 'o:Entity'" /> -->
			<!-- Example for using starts-with with the name() function. -->
			<!-- <ElementCondition xpath="starts-with(name(), 'o:')" /> -->
			
			<!-- You can nest conditions groups (OneOfConditions and AllConditions). See the example below. -->
			<!--
			<OneOffConditions>
				<ElementCondition xpath="name() = 'SomeElementName'" />
				<ElementCondition xpath="name() = 'SomeOtherElementName'" />
				<AllConditions>
					<ElementCondition xpath="parent::node()[name() = 'c:Entities'" />
					<ElementCondition xpath="starts-with(./Code, 'ENT')" />
				</AllConditions>
			</OneOffConditions>
			 -->
			 
			<!-- Here we specify which information to include as an attribute on the xi:include tag. -->
			<IncludeAttributes>
				<IncludeAttribute name="ObjectID" xpath="./ObjectID" />
			</IncludeAttributes>
			<!-- Here we specify the xpath to execute on a decomposable element to get the file name (without .xml). -->
			<TargetFileName xpath="./Code" />
		</DecomposableElement>

	</Decompose>
</PowerDeComposerConfig>