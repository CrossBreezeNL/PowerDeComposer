<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<PowerDeComposerConfig>
	<Decompose>
	
		<!-- Specify a XPath to execute on both sides (composed and decomposed) to decide whether the decompose. -->
		<!-- If the value doesn't exist on both sides we do nothing. -->
		<!-- If the value exists on one side but not on the other side, we decompose. -->
		<!-- If the value exists on both sides, we decompose if the value is different. -->
		<ChangeDetection xpath="/processing-instruction('PowerDesigner')/@LastModificationDate" />
	
		<!-- Configuration on how to replace identifiers. -->
		<IdentifierReplacement identifierNodeXPath="//*/@Id[../ObjectID]" replacementValueXPath="../ObjectID" referencingNodeXPath="//*/@Ref" />
	
		<!-- Specify the nodes to remove before decomposing. -->
		<NodeRemovals>
			<!-- Remove the object count on the PowerDesigner processing instruction. -->
			<NodeRemoval xpath="/processing-instruction('PowerDesigner')/@Objects" />
			<!-- Remove the symbols count on the PowerDesigner processing instruction. -->
			<NodeRemoval xpath="/processing-instruction('PowerDesigner')/@Symbols" />
			<!--  Remove the last modification date on the PowerDesigner processing instruction. -->
			<NodeRemoval xpath="/processing-instruction('PowerDesigner')/@LastModificationDate" />
			
			<!-- Remove the CreationDate, Creator, ModificationDate & Modifier from all Shortcuts. -->
			<NodeRemoval xpath="//Shortcut/CreationDate" />
			<NodeRemoval xpath="//Shortcut/Creator" />
			<NodeRemoval xpath="//Shortcut/ModificationDate" />
			<NodeRemoval xpath="//Shortcut/Modifier" />
			
			<!-- Remove the TargetModelLastModificationDate from all TargetModels. -->
			<NodeRemoval xpath="//TargetModel/TargetModelLastModificationDate" />
		</NodeRemovals>
		
		<!-- Specify which elements should be decomposed. -->
		<!-- The DecomposableElement is implicitly a AllConditions group. -->
		<DecomposableElement>
			<!-- The element must have a ObjectID and a Code element as childs. -->
			<ElementCondition xpath="./ObjectID and ./Code" />
			<!-- Use the parent axis on the current node to set a predicate on the parent. -->
			<!-- Decompose all elements where the parent name starts with 'c:' (these are the collections in PowerDesigner). -->
			<ElementCondition xpath="parent::node()[starts-with(name(), 'c:')]" />
			<!-- Don't decompose the Children collection (this is the higher level collection of the model). -->
			<ElementCondition xpath="parent::node()[name() != 'c:Children']" />
			<!-- LDM collections not to decompose. -->
			<ElementCondition xpath="parent::node()[name() != 'c:Attributes']" />
			<ElementCondition xpath="parent::node()[name() != 'c:Identifiers']" />
			<!-- PDM collections not to decompose. -->
			<ElementCondition xpath="parent::node()[name() != 'c:Columns']" />
			<ElementCondition xpath="parent::node()[name() != 'c:Keys']" />
			<!-- Don't decompose sub shortcuts. -->
			<ElementCondition xpath="parent::node()[name() != 'c:SubShortcuts']" />
			
			<!-- Example for comparing on the element name. -->
			<!-- <ElementCondition xpath="name() = 'o:Entity'" /> -->
			<!-- Example for using starts-with with the name() function. -->
			<!-- <ElementCondition xpath="starts-with(name(), 'o:')" /> -->
			
			<!-- You can nest conditions groups (OneOfConditions and AllConditions). See the example below. -->
			<!--
			<OneOffConditions>
				<ElementCondition xpath="name() = 'SomeElementName'" />
				<ElementCondition xpath="name() = 'SomeOtherElementName'" />
				<AllConditions>
					<ElementCondition xpath="parent::node()[name() = 'c:Entities'" />
					<ElementCondition xpath="starts-with(./Code, 'ENT')" />
				</AllConditions>
			</OneOffConditions>
			 -->
			 
			<!-- Here we specify which information to include as an attribute on the xi:include tag. -->
			<IncludeAttributes />
			<!--<IncludeAttributes>
				<IncludeAttribute name="ObjectID" xpath="./ObjectID" />
			</IncludeAttributes>-->
			
			<!-- Here we specify the xpath to execute on a decomposable element to get the file name (without .xml). -->
			<!-- For items with a Code element and it is unique in its scope, we use the Code. -->
			<!-- For items with a Code and ObjectID element and it is NOT unique in its scope, we use the Code and ObjectID. -->
            <!-- For items without a Code element, but with an ObjectID we use the ObjectID. -->
            <!-- For items which don't have a Code and ObjectID element, we use the name of the element. -->
            <TargetFileName xpath="concat(
                    substring(translate(normalize-space(./Code), ' ', '_'),                          1, count(./Code) * number(not(./Code = preceding-sibling::*/child::Code)) * string-length(translate(normalize-space(./Code), ' ', '_'))),
                    substring(concat(translate(normalize-space(./Code), ' ', '_'), '_', ./ObjectID), 1, count(./Code) * number(./Code = preceding-sibling::*/child::Code) * string-length(concat(translate(normalize-space(./Code), ' ', '_'), '_', ./ObjectID))),
                    substring(./ObjectID,                                                            1, abs(count(./Code) - 1) * count(./ObjectID) * string-length(./ObjectID)),
                    substring(translate(name(), ':', '_'),                                           1, abs(count(./Code) - 1) * abs(count(./ObjectID) - 1) * string-length(name()))
                )" />
                
			<!-- Here we specify the xpath to execute on a decomposable element to get the folder name to store the file in. -->
            <!-- For items with a Stereotype element, we use the Stereotype. -->
            <!-- For items with a TargetStereotype element, we use the TargetStereotype (the TargetStereotype is specified in case of shortcuts). -->
            <!-- For items which don't have a Stereotype or TargetStereotype element, we use the name of the element. -->
            <TargetFolderName xpath="concat(
                    substring(./Stereotype,                1, count(./Stereotype[text()]) * string-length(./Stereotype)),
                    substring(./TargetStereotype,          1, abs(count(./Stereotype[text()]) - 1) * count(./TargetStereotype[text()]) * string-length(./Stereotype)),
                    substring(translate(name(), ':', '_'), 1, abs(count(./Stereotype[text()]) - 1) * abs(count(./TargetStereotype[text()]) - 1) * string-length(name()))
                )" />
		</DecomposableElement>

	</Decompose>
</PowerDeComposerConfig>